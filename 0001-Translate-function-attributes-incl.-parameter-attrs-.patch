From aded5afb04f02b1b057db96cd9a8a5e9d1ff47fc Mon Sep 17 00:00:00 2001
From: Viktoria Maximova <viktoria.maksimova@intel.com>
Date: Fri, 25 Feb 2022 15:44:56 +0300
Subject: Translate function attributes (incl. parameter attrs) for entry point
 kernels (#1409)

* Restore `noalias` parameter attribute test check, removed in 7f168b27.
* Restore the translation of function attributes and function parameter attributes
  for entry point kernels, accidentally dropped in 85815e7 "add an entry point wrapper around functions".

Original commit:
https://github.com/KhronosGroup/SPIRV-LLVM-Translator/commit/aded5af
---
 lib/SPIRV/SPIRVReader.cpp             | 93 ++++++++++++++-------------
 lib/SPIRV/SPIRVReader.h               |  1 +
 test/spirv_param_decorations_quals.ll |  4 +-
 3 files changed, 52 insertions(+), 46 deletions(-)

diff --git a/lib/SPIRV/SPIRVReader.cpp b/lib/SPIRV/SPIRVReader.cpp
index dd856076b..6c98cbbc7 100644
--- a/lib/SPIRV/SPIRVReader.cpp
+++ b/lib/SPIRV/SPIRVReader.cpp
@@ -2768,6 +2768,53 @@ bool SPIRVToLLVM::foreachFuncCtlMask(SourceTy Source, FuncTy Func) {
   return true;
 }
 
+void SPIRVToLLVM::transFunctionAttrs(SPIRVFunction *BF, Function *F) {
+  if (BF->hasDecorate(DecorationReferencedIndirectlyINTEL))
+    F->addFnAttr("referenced-indirectly");
+  if (isFuncNoUnwind())
+    F->addFnAttr(Attribute::NoUnwind);
+  foreachFuncCtlMask(BF, [&](Attribute::AttrKind Attr) { F->addFnAttr(Attr); });
+
+  for (Function::arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E;
+       ++I) {
+    auto *BA = BF->getArgument(I->getArgNo());
+    mapValue(BA, &(*I));
+    setName(&(*I), BA);
+    BA->foreachAttr([&](SPIRVFuncParamAttrKind Kind) {
+      Attribute::AttrKind LLVMKind = SPIRSPIRVFuncParamAttrMap::rmap(Kind);
+      Type *AttrTy = nullptr;
+      switch (LLVMKind) {
+      case Attribute::AttrKind::ByVal:
+        AttrTy = cast<PointerType>(I->getType())->getPointerElementType();
+        break;
+      case Attribute::AttrKind::StructRet:
+        AttrTy = I->getType();
+        break;
+      default:
+        break; // do nothing
+      }
+      // Make sure to use a correct constructor for a typed/typeless attribute
+      auto A = AttrTy ? Attribute::get(*Context, LLVMKind, AttrTy)
+                      : Attribute::get(*Context, LLVMKind);
+      I->addAttr(A);
+    });
+
+    AttrBuilder Builder(*Context);
+    SPIRVWord MaxOffset = 0;
+    if (BA->hasDecorate(DecorationMaxByteOffset, 0, &MaxOffset))
+      Builder.addDereferenceableAttr(MaxOffset);
+    SPIRVWord AlignmentBytes = 0;
+    if (BA->hasDecorate(DecorationAlignment, 0, &AlignmentBytes))
+      Builder.addAlignmentAttr(AlignmentBytes);
+    I->addAttrs(Builder);
+  }
+  BF->foreachReturnValueAttr([&](SPIRVFuncParamAttrKind Kind) {
+    if (Kind == FunctionParameterAttributeNoWrite)
+      return;
+    F->addRetAttr(SPIRSPIRVFuncParamAttrMap::rmap(Kind));
+  });
+}
+
 Function *SPIRVToLLVM::transFunction(SPIRVFunction *BF) {
   auto Loc = FuncMap.find(BF);
   if (Loc != FuncMap.end())
@@ -2787,6 +2834,7 @@ Function *SPIRVToLLVM::transFunction(SPIRVFunction *BF) {
         F->setDSOLocal(false);
         F = cast<Function>(mapValue(BF, F));
         mapFunction(BF, F);
+        transFunctionAttrs(BF, F);
         return F;
       }
     }
@@ -2816,50 +2864,7 @@ Function *SPIRVToLLVM::transFunction(SPIRVFunction *BF) {
 
   F->setCallingConv(IsKernel ? CallingConv::SPIR_KERNEL
                              : CallingConv::SPIR_FUNC);
-  if (BF->hasDecorate(DecorationReferencedIndirectlyINTEL))
-    F->addFnAttr("referenced-indirectly");
-  if (isFuncNoUnwind())
-    F->addFnAttr(Attribute::NoUnwind);
-  foreachFuncCtlMask(BF, [&](Attribute::AttrKind Attr) { F->addFnAttr(Attr); });
-
-  for (Function::arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E;
-       ++I) {
-    auto BA = BF->getArgument(I->getArgNo());
-    mapValue(BA, &(*I));
-    setName(&(*I), BA);
-    BA->foreachAttr([&](SPIRVFuncParamAttrKind Kind) {
-      Attribute::AttrKind LLVMKind = SPIRSPIRVFuncParamAttrMap::rmap(Kind);
-      Type *AttrTy = nullptr;
-      switch (LLVMKind) {
-      case Attribute::AttrKind::ByVal:
-        AttrTy = cast<PointerType>(I->getType())->getPointerElementType();
-        break;
-      case Attribute::AttrKind::StructRet:
-        AttrTy = I->getType();
-        break;
-      default:
-        break; // do nothing
-      }
-      // Make sure to use a correct constructor for a typed/typeless attribute
-      auto A = AttrTy ? Attribute::get(*Context, LLVMKind, AttrTy)
-                      : Attribute::get(*Context, LLVMKind);
-      I->addAttr(A);
-    });
-
-    AttrBuilder Builder(*Context);
-    SPIRVWord MaxOffset = 0;
-    if (BA->hasDecorate(DecorationMaxByteOffset, 0, &MaxOffset))
-      Builder.addDereferenceableAttr(MaxOffset);
-    SPIRVWord AlignmentBytes = 0;
-    if (BA->hasDecorate(DecorationAlignment, 0, &AlignmentBytes))
-      Builder.addAlignmentAttr(AlignmentBytes);
-    I->addAttrs(Builder);
-  }
-  BF->foreachReturnValueAttr([&](SPIRVFuncParamAttrKind Kind) {
-    if (Kind == FunctionParameterAttributeNoWrite)
-      return;
-    F->addRetAttr(SPIRSPIRVFuncParamAttrMap::rmap(Kind));
-  });
+  transFunctionAttrs(BF, F);
 
   // Creating all basic blocks before creating instructions.
   for (size_t I = 0, E = BF->getNumBasicBlock(); I != E; ++I) {
diff --git a/lib/SPIRV/SPIRVReader.h b/lib/SPIRV/SPIRVReader.h
index 4cef66838..4be1dd115 100644
--- a/lib/SPIRV/SPIRVReader.h
+++ b/lib/SPIRV/SPIRVReader.h
@@ -95,6 +95,7 @@ public:
   std::vector<Value *> transValue(const std::vector<SPIRVValue *> &,
                                   Function *F, BasicBlock *);
   Function *transFunction(SPIRVFunction *F);
+  void transFunctionAttrs(SPIRVFunction *BF, Function *F);
   Value *transBlockInvoke(SPIRVValue *Invoke, BasicBlock *BB);
   Instruction *transWGSizeQueryBI(SPIRVInstruction *BI, BasicBlock *BB);
   Instruction *transSGSizeQueryBI(SPIRVInstruction *BI, BasicBlock *BB);
diff --git a/test/spirv_param_decorations_quals.ll b/test/spirv_param_decorations_quals.ll
index fe5866d8e..24a8ee981 100644
--- a/test/spirv_param_decorations_quals.ll
+++ b/test/spirv_param_decorations_quals.ll
@@ -36,7 +36,7 @@ entry:
 !9 = !{!8}
 !10 = !{!9}
 
-; CHECK-SPV-IR: define spir_kernel void @k(i32 addrspace(1)* %a)
+; CHECK-SPV-IR: define spir_kernel void @k(i32 addrspace(1)* noalias %a)
 ; CHECK-SPV-IR-SAME: !kernel_arg_type_qual ![[KernelArgTypeQual:[0-9]+]]
 ; CHECK-SPV-IR-SAME: !spirv.ParameterDecorations ![[ParamDecoListId:[0-9]+]]
 ; CHECK-SPV-IR-DAG: ![[ParamDecoListId]] = !{![[ParamDecoId:[0-9]+]]}
@@ -46,5 +46,5 @@ entry:
 ; CHECK-SPV-IR-DAG: ![[KernelArgTypeQual]] = !{!"volatile restrict"}
 
 ; CHECK-LLVM-NOT: !spirv.ParameterDecorations
-; CHECK-LLVM: define spir_kernel void @k(i32 addrspace(1)* %a) {{.*}} !kernel_arg_type_qual ![[KernelArgTypeQual:[0-9]+]] {{.*}} {
+; CHECK-LLVM: define spir_kernel void @k(i32 addrspace(1)* noalias %a) {{.*}} !kernel_arg_type_qual ![[KernelArgTypeQual:[0-9]+]] {{.*}} {
 ; CHECK-LLVM-DAG: ![[KernelArgTypeQual]] = !{!"volatile restrict"}
-- 
2.39.1

